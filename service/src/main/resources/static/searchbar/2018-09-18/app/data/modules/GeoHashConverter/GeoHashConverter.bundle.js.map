{"version":3,"sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/./src/scripts/GeoHashConverter/GeoHashConverter.js","webpack://[name]/./node_modules/latlon-geohash/latlon-geohash.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","geoHashToLatLng","geoHash","position","Geohash","decode","lat","lng","lon","latLngToGeoHash","per","encode","getGeoHashBounds","bounds","ne","sw","base32","precision","hash","posn","Number","isNaN","Error","idx","bit","evenBit","geohash","latMin","latMax","lonMin","lonMax","length","lonMid","latMid","charAt","toFixed","Math","floor","log","LN10","toLowerCase","chr","indexOf","bitN","adjacent","direction","lastCh","slice","parent","type","e","w","neighbours","se","nw"],"mappings":"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","file":"GeoHashConverter/GeoHashConverter.bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GeoHashConverter\"] = factory();\n\telse\n\t\troot[\"GeoHashConverter\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 13);\n","import * as Geohash from 'latlon-geohash';\n\nexport function geoHashToLatLng (geoHash) {\n  const position = Geohash.decode(geoHash);\n  return {\n    lat: position.lat,\n    lng: position.lon\n   };\n}\n\nexport function latLngToGeoHash (lat, lng, per) {\n return Geohash.encode(lat, lng, per);\n}\n\nexport function getGeoHashBounds (geoHash) {\n  let bounds = Geohash.bounds(geoHash);\n  return {\n    ne: {lat: bounds.ne.lat, lng: bounds.ne.lon},\n    sw: {lat: bounds.sw.lat, lng: bounds.sw.lon},\n  }\n}\n","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Geohash encoding/decoding and associated functions   (c) Chris Veness 2014-2016 / MIT Licence  */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n'use strict';\n\n\n/**\n * Geohash encode, decode, bounds, neighbours.\n *\n * @namespace\n */\nvar Geohash = {};\n\n/* (Geohash-specific) Base32 map */\nGeohash.base32 = '0123456789bcdefghjkmnpqrstuvwxyz';\n\n/**\n * Encodes latitude/longitude to geohash, either to specified precision or to automatically\n * evaluated precision.\n *\n * @param   {number} lat - Latitude in degrees.\n * @param   {number} lon - Longitude in degrees.\n * @param   {number} [precision] - Number of characters in resulting geohash.\n * @returns {string} Geohash of supplied latitude/longitude.\n * @throws  Invalid geohash.\n *\n * @example\n *     var geohash = Geohash.encode(52.205, 0.119, 7); // geohash: 'u120fxw'\n */\nGeohash.encode = function(lat, lon, precision) {\n    // infer precision?\n    if (typeof precision == 'undefined') {\n        // refine geohash until it matches precision of supplied lat/lon\n        for (var p=1; p<=12; p++) {\n            var hash = Geohash.encode(lat, lon, p);\n            var posn = Geohash.decode(hash);\n            if (posn.lat==lat && posn.lon==lon) return hash;\n        }\n        precision = 12; // set to maximum\n    }\n\n    lat = Number(lat);\n    lon = Number(lon);\n    precision = Number(precision);\n\n    if (isNaN(lat) || isNaN(lon) || isNaN(precision)) throw new Error('Invalid geohash');\n\n    var idx = 0; // index into base32 map\n    var bit = 0; // each char holds 5 bits\n    var evenBit = true;\n    var geohash = '';\n\n    var latMin =  -90, latMax =  90;\n    var lonMin = -180, lonMax = 180;\n\n    while (geohash.length < precision) {\n        if (evenBit) {\n            // bisect E-W longitude\n            var lonMid = (lonMin + lonMax) / 2;\n            if (lon >= lonMid) {\n                idx = idx*2 + 1;\n                lonMin = lonMid;\n            } else {\n                idx = idx*2;\n                lonMax = lonMid;\n            }\n        } else {\n            // bisect N-S latitude\n            var latMid = (latMin + latMax) / 2;\n            if (lat >= latMid) {\n                idx = idx*2 + 1;\n                latMin = latMid;\n            } else {\n                idx = idx*2;\n                latMax = latMid;\n            }\n        }\n        evenBit = !evenBit;\n\n        if (++bit == 5) {\n            // 5 bits gives us a character: append it and start over\n            geohash += Geohash.base32.charAt(idx);\n            bit = 0;\n            idx = 0;\n        }\n    }\n\n    return geohash;\n};\n\n\n/**\n * Decode geohash to latitude/longitude (location is approximate centre of geohash cell,\n *     to reasonable precision).\n *\n * @param   {string} geohash - Geohash string to be converted to latitude/longitude.\n * @returns {{lat:number, lon:number}} (Center of) geohashed location.\n * @throws  Invalid geohash.\n *\n * @example\n *     var latlon = Geohash.decode('u120fxw'); // latlon: { lat: 52.205, lon: 0.1188 }\n */\nGeohash.decode = function(geohash) {\n\n    var bounds = Geohash.bounds(geohash); // <-- the hard work\n    // now just determine the centre of the cell...\n\n    var latMin = bounds.sw.lat, lonMin = bounds.sw.lon;\n    var latMax = bounds.ne.lat, lonMax = bounds.ne.lon;\n\n    // cell centre\n    var lat = (latMin + latMax)/2;\n    var lon = (lonMin + lonMax)/2;\n\n    // round to close to centre without excessive precision: ⌊2-log10(Δ°)⌋ decimal places\n    lat = lat.toFixed(Math.floor(2-Math.log(latMax-latMin)/Math.LN10));\n    lon = lon.toFixed(Math.floor(2-Math.log(lonMax-lonMin)/Math.LN10));\n\n    return { lat: Number(lat), lon: Number(lon) };\n};\n\n\n/**\n * Returns SW/NE latitude/longitude bounds of specified geohash.\n *\n * @param   {string} geohash - Cell that bounds are required of.\n * @returns {{sw: {lat: number, lon: number}, ne: {lat: number, lon: number}}}\n * @throws  Invalid geohash.\n */\nGeohash.bounds = function(geohash) {\n    if (geohash.length === 0) throw new Error('Invalid geohash');\n\n    geohash = geohash.toLowerCase();\n\n    var evenBit = true;\n    var latMin =  -90, latMax =  90;\n    var lonMin = -180, lonMax = 180;\n\n    for (var i=0; i<geohash.length; i++) {\n        var chr = geohash.charAt(i);\n        var idx = Geohash.base32.indexOf(chr);\n        if (idx == -1) throw new Error('Invalid geohash');\n\n        for (var n=4; n>=0; n--) {\n            var bitN = idx >> n & 1;\n            if (evenBit) {\n                // longitude\n                var lonMid = (lonMin+lonMax) / 2;\n                if (bitN == 1) {\n                    lonMin = lonMid;\n                } else {\n                    lonMax = lonMid;\n                }\n            } else {\n                // latitude\n                var latMid = (latMin+latMax) / 2;\n                if (bitN == 1) {\n                    latMin = latMid;\n                } else {\n                    latMax = latMid;\n                }\n            }\n            evenBit = !evenBit;\n        }\n    }\n\n    var bounds = {\n        sw: { lat: latMin, lon: lonMin },\n        ne: { lat: latMax, lon: lonMax },\n    };\n\n    return bounds;\n};\n\n\n/**\n * Determines adjacent cell in given direction.\n *\n * @param   geohash - Cell to which adjacent cell is required.\n * @param   direction - Direction from geohash (N/S/E/W).\n * @returns {string} Geocode of adjacent cell.\n * @throws  Invalid geohash.\n */\nGeohash.adjacent = function(geohash, direction) {\n    // based on github.com/davetroy/geohash-js\n\n    geohash = geohash.toLowerCase();\n    direction = direction.toLowerCase();\n\n    if (geohash.length === 0) throw new Error('Invalid geohash');\n    if ('nsew'.indexOf(direction) == -1) throw new Error('Invalid direction');\n\n    var neighbour = {\n        n: [ 'p0r21436x8zb9dcf5h7kjnmqesgutwvy', 'bc01fg45238967deuvhjyznpkmstqrwx' ],\n        s: [ '14365h7k9dcfesgujnmqp0r2twvyx8zb', '238967debc01fg45kmstqrwxuvhjyznp' ],\n        e: [ 'bc01fg45238967deuvhjyznpkmstqrwx', 'p0r21436x8zb9dcf5h7kjnmqesgutwvy' ],\n        w: [ '238967debc01fg45kmstqrwxuvhjyznp', '14365h7k9dcfesgujnmqp0r2twvyx8zb' ],\n    };\n    var border = {\n        n: [ 'prxz',     'bcfguvyz' ],\n        s: [ '028b',     '0145hjnp' ],\n        e: [ 'bcfguvyz', 'prxz'     ],\n        w: [ '0145hjnp', '028b'     ],\n    };\n\n    var lastCh = geohash.slice(-1);    // last character of hash\n    var parent = geohash.slice(0, -1); // hash without last character\n\n    var type = geohash.length % 2;\n\n    // check for edge-cases which don't share common prefix\n    if (border[direction][type].indexOf(lastCh) != -1 && parent !== '') {\n        parent = Geohash.adjacent(parent, direction);\n    }\n\n    // append letter for direction to parent\n    return parent + Geohash.base32.charAt(neighbour[direction][type].indexOf(lastCh));\n};\n\n\n/**\n * Returns all 8 adjacent cells to specified geohash.\n *\n * @param   {string} geohash - Geohash neighbours are required of.\n * @returns {{n,ne,e,se,s,sw,w,nw: string}}\n * @throws  Invalid geohash.\n */\nGeohash.neighbours = function(geohash) {\n    return {\n        'n':  Geohash.adjacent(geohash, 'n'),\n        'ne': Geohash.adjacent(Geohash.adjacent(geohash, 'n'), 'e'),\n        'e':  Geohash.adjacent(geohash, 'e'),\n        'se': Geohash.adjacent(Geohash.adjacent(geohash, 's'), 'e'),\n        's':  Geohash.adjacent(geohash, 's'),\n        'sw': Geohash.adjacent(Geohash.adjacent(geohash, 's'), 'w'),\n        'w':  Geohash.adjacent(geohash, 'w'),\n        'nw': Geohash.adjacent(Geohash.adjacent(geohash, 'n'), 'w'),\n    };\n};\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\nif (typeof module != 'undefined' && module.exports) module.exports = Geohash; // CommonJS, node.js\n"],"sourceRoot":""}